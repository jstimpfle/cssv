Whitespace separated literals (WSL)
===================================

(See https://github.com/jstimpfle/relational-calculus for a simple
application of WSL)

WSL is a human friendly plain text format for relational databases. A
database notated as WSL might look like the following:

% DOMAIN Person Atom
% DOMAIN PersonDesc String
% DOMAIN Gender Enum male female
%
% TABLE Person Person Gender PersonDesc
% TABLE Friends Person Person
% TABLE Couple Person Person
%
Person Jack male "Jack of all Trades"
Person John male "John Doe"
Person Jane female "Jane Dane"
Friends Jack Jane
Couple John Jane

WSL encourages normalization and emphasizes the practical properties of
plain text -- in particular ease of editing and version-controlling.
NULL values and column names are omitted to encourage tables with fewer
columns but more relational meaning.

SYNTAX
======

WSL is a plain text format for relational databases.

"Plain text" here means mostly ASCII and optionally UTF-8. The control
character bytes 0x00-0x1f, 0x7f are completely forbidden, except 0x09
(tab) and 0x0a (newline) which are allowed as lexical separators.

A WSL database is normally embedded in a single file or stream, and
contains a header followed by the relational data.

Each line of the header must be prefixed with a '%' (0x25) character.
The header holds the schema of database, which is given in the schema
language discussed later.

After the header, each row of the data is given on a single line
(extinct of newline and carriage return characters) as a sequence of
tokens which are separated by one or more tab (0x09) or space (0x20)
characters.

The first token is always the name of the table to which the row
belongs. (table names must be valid C identifiers).

The remaining tokens are the values of the row (in order), i.e. there
should be as many tokens following the table name as there are columns
in the table. Syntactically, each of these remaining tokens is either an
*atom* or a *string literal*.

An atom is a sequence of bytes from the ASCII graphical range except
double quote, i.e. 0x21, 0x23-0x7e. Optionally implementations can
support UTF-8 as long as single-byte sequences are only 0x21, 0x23-0x7e.
Atoms are useful for numbers and identifiers, and often serve as keys in
relations. But they can be used for almost anything which does not
contain whitespace. For example, URLs, dates, times...

A string literal starts with a double quote (0x22) character and ends at
the first following un-escaped double quote character. By means of
escaping string literals can represent arbitrary data (and so they are
meant for accompanying data, like comments, notes, binary data...).
Escaping is C-style: the backslash character introduces an escape
sequence. The following escape sequences and interpretations as (binary)
data are possible:

Escape sequence | Interpretation
--------------------------------
\\              | backslash (0x5c)
\"              | double quote (0x22)
\n              | newline (0x0a)
\r              | carriage return (0x0d)
\t              | horizontal tab (0x09)
\xHH            | Byte in (lower case) hexadecimal notation

Hexadecimal notation is required for the representation of ASCII control
characters (which are not allowed anywhere in the file). It's also
generally encouraged for binary data (i.e., if the data is not
interpreted as characters). In the interest of normalization it is
discouraged otherwise.

Of course implementations might do additional interpretation to extend
the interpretation of string literals specified here, given additional
type information. But the above syntactical restrictions define a
maximal set of allowed sequences (for example, "\ESC" is not a valid
string literal) and also what strings must be interpreted as equal (for
example, "\x20" and " ").

DATABASE SCHEMA LANGUAGE
========================

The schema language supports declaration of user-defined domains (column
data types), base tables (row data types), and database integrity
constraints (primary and foreign keys). These are the most essential
ingredients to relational databases. The following is a more elaborate
example of a schema in WSL. The lines are prefixed with '%' as required
for database inline notation.

% SCHEMA NAME example-schema
% SCHEMA VERSION 1
%
% DOC SCHEMA no documentation today
%
% DOC DOMAIN Person registered person
% DOC DOMAIN Gender gender of a person
% DOC DOMAIN Comment free-form comment
%
% DOC TABLE Person This table is meant to store all persons
% DOC TABLE Friends
% DOC TABLE Couple
%
% DOMAIN User Atom
% DOMAIN Gender Enum male female
% DOMAIN Comment String
%
% TABLE Person User Gender Comment
% TABLE Couple User User
% TABLE Friends User User
%
% KEY Person P *
% REFERENCE Friends P * => Person P *
% REFERENCE Friends * P => Person P *
% REFERENCE Couple P * => Person P *
% REFERENCE Couple * P => Person P *

Explanation of this language follows.

LEXICAL SYNTAX OF THE SCHEMA LANGUAGE
-------------------------------------

The lexical syntax of the schema language is designed to be very easy
easy to parse. Each schema is encoded as a sequence of statements, where
each statement stands on its own line and consists of a list of tokens
separated strictly by whitespace. There are some documentation
statements which have free-form text arguments, but it should be ok to
consider the amount of whitespace there as insignificant, too.

That means parsers can just start by splitting into lines on newline
characters, and each line into words on whitespace characters.

In inline database notation, each line must start with a '%' character
but this is not part of the schema syntax.

DECLARATION OF DOMAINS
----------------------

A DOMAIN line declares a new domain. The new domain's values will
usually be interpreted as distinct from all other domains' values.

The first following token is the name of the new domain. It must match
the regular expression [a-zA-Z][a-zA-Z0-9]*.

The next token is the name of a basic datatype. Basic datatypes specify
how values of a domain are represented internally, and externally within
the syntactic constraints for atoms and string literals. Furthermore
each basic datatype defines a total ordering on all its values.

There might be additional tokens following. For example, the "Enum"
basic datatype expects one more token for each valid value.

The following datatypes must be built in to every implementation:

 - Atom (Atom syntax)
 - String (String literal syntax, UTF8 encoded text)
 - Enum (Atom syntax, fixed set of valid values)
 - Integer (Atom syntax, representation in base 10)

Other useful types:

 - Decimal (Atom syntax, Configurable number of decimal places)
 - Base64 (Atom syntax, base64-encoded binary data)

The most important point of making a distinction between types other
than atom or string literal syntax is to enable the implementations of
special functions (for example, round :: Decimal -> Integer) and to get
sorting right.

DOMAIN CONSTRAINTS
------------------

A facility to constrain the values in a domain (to use a subset of the
values allowed by the basic datatypes) would be nice, but it's not clear
how this should be realized.

The idea is that such constraints can be specified separatedly to the
declaration of each domain, and possibly on the external (instead of
only internal) representation, and are not mandatory for all
implementations to support. This allows specialized syntax for
fine-grained constraints that can be enforced by specialized tools.

UNIQUE KEY CONSTRAINTS
----------------------

A unique key constraint is declared by a line starting with KEY. After
the KEY token, the name of a table, and one more token for each column
in the table, are expected. Each column token should be either "*" or an
uppercase identifier. All identifiers in a unique key declaration line
must be distinct. The interpretation is that those columns which are
paired with identifiers (i.e. not "*") form the unique key. For example,

KEY Person P * *

specifies that the Person table (which has three columns) is unique in
the first column, i.e. for a given value there is at most one Person row
which has that value in the first column.

FOREIGN KEY CONSTRAINTS
-----------------------

A foreign key constraint is declared by a line starting with the token
REFERENCE. After the REFERENCE token, two table-column token sequences,
as described in the UNIQUE KEY section, are expected. The two sequences
must be separated by a => token. The identifiers must be distinct per
sequence, and the same must be used in both sequences. For example,

REFERENCE Friends P * => Person P * *
REFERENCE Friends * P => Person P * *

declares one foreign key constraint from table Friends (first column) to
Person (first column), and one foreign key constraint from Friends
(second column) to Person (first column).

REFERENCE Perm D R * * => Repo D R *

declares a multi-column foreign key constraint from Perm to Repo.
