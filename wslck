#!/usr/bin/python3

SYNTAX_ATOM = 0
SYNTAX_STRING = 1

class L1:
    def __init__(self, iter):
        self.iter = iter
        self.hasx = False
    def unget(self, x):
        assert not self.hasx
        self.x = x
        self.hasx = True
    def __next__(self):
        if self.hasx:
            out = self.x
            self.x = None
            self.hasx = False
            return out
        return next(self.iter)
    def __iter__(self):
        return self

def u8(bin):
    try:
        return bin.decode('utf-8')
    except UnicodeDecodeError:
        s = bin.decode('utf-8', 'backslashreplace')
        raise Exception('Not valid UTF-8: "%s"' % (s,))

def u8j(bins):
    return ' '.join(u8(bin) for bin in bins)

def BinaryLines(buf):
    for line in buf.readlines():
        yield bytes(line, 'utf-8')

class Datatype:
    "abstract column"
    syntaxtype = None  # SYNTAX_ATOM or SYNTAX_STRING
    @staticmethod
    def decode(token):
        pass
    @staticmethod
    def encode(value):
        pass

def parse_atom_datatype(line):
    if line:
        raise Exception('Construction of Atom datatype does not receive any arguments')
    class AtomDatatype:
        syntaxtype = SYNTAX_ATOM
        @staticmethod
        def decode(token):
            return token
        @staticmethod
        def encode(value):
            return token
    return AtomDatatype

def parse_string_datatype(line):
    if line:
        raise Exception('Construction of String datatype does not receive any arguments')
    class StringDatatype:
        syntaxtype = SYNTAX_STRING
        @staticmethod
        def decode(token):
            return token
        @staticmethod
        def encode(value):
            return token
    return StringDatatype

def parse_integer_datatype(line):
    if line:
        raise Exception('Construction of Integer datatype does not receive any arguments')
    class IntegerDatatype:
        syntaxtype = SYNTAX_ATOM
        @staticmethod
        def decode(token):
            try:
                return int(token)
            except ValueError:
                raise Exception('Failed to parse %s as integer' %(u8(token),))
        @staticmethod
        def encode(value):
            return bytes(str(value), 'utf-8')
    return IntegerDatatype

def parse_enum_datatype(line):
    values = line.split()
    class EnumDatatype:
        syntaxtype = SYNTAX_ATOM
        @staticmethod
        def decode(token):
            if token not in values:
                raise Exception('invalid token "%s"; valid tokens are %s' %(u8(token), u8j(values)))
            return token
        @staticmethod
        def encode(value):
            return value
    return EnumDatatype

default_parsers = (
    (b'Atom', parse_atom_datatype),
    (b'String', parse_string_datatype),
    (b'Enum', parse_enum_datatype),
    (b'Integer', parse_integer_datatype)
)

class Schema:
    def __init__(self, tableinfo, keys, refs):
        self.tableinfo = tableinfo  # { name: columns }
        self.keys = keys  # { name: (table, column indices) }
        self.refs = refs  # { name: (table, column indices, table, column indices) }

def key_from_row(row, ix):
    return tuple(row[i] for i in ix)

class Database:
    def __init__(self, schema):
        self.schema = schema
        self.relvar = {}  # { name: set() }
        self.key_index = {}  # { name: set() }
        self.ref_index = {}  # { name: index of key in foreign table }
        for name in schema.tableinfo:
            self.relvar[name] = set()
        for name in schema.keys:
            self.key_index[name] = set()
        for name in schema.refs:
            self.ref_index[name] = set()

    def add_row(self, table, row):
        if table not in self.schema.tableinfo:
            raise Exception('No such table: %s' %(table,))
        t = self.relvar[table]
        if len(row) != len(self.schema.tableinfo[table]):
            raise Exception('Can\'t add row %s to table %s: wrong arity' %(u8(row), u8(table)))
        if row in t:
            raise Exception('Duplicate row %s' %(row,))
        t.add(row)
        for name, (ut, ix) in self.schema.keys.items():
            if ut == table:
                k = key_from_row(row, ix)
                ux = self.key_index[name]
                if k in ux:
                    raise Exception('Unique constraint "%s" violated by row %s %s' %(u8(name), u8(ut), u8j(row)))
                ux.add(k)
        for name, (_, _, ft, fix) in self.schema.refs.items():
            if ft == table:
                k = key_from_row(row, fix)
                fx = self.ref_index[name]
                fx.add(k)

    def check_referential_integrity(self):
        for name, (lt, lix, _, _) in self.schema.refs.items():
            for row in self.relvar[lt]:
                k = key_from_row(row, lix)
                fx = self.ref_index[name]
                if k not in fx:
                    raise Exception('Foreign key constraint "%s" violated by %s %s"' %(u8(name), u8(lt), u8j(row)))

def parse_datatype(line, parser):
    ws = line.split(None, 1)
    if ws:
        name, rest = ws[0], ws[1] if len(ws) == 2 else b''
        if name not in parser:
            raise Exception('No parser for datatype "%s" available while parsing DOMAIN declaration' %(u8(name,)))
        datatype = parser[name](rest)
        return datatype
    raise Exception('Failed to parse %s as datatype declaration' %(u8(line),))

def parse_domain(line, parsers):
    ws = line.split(None, 1)
    if ws:
        name, rest = ws[0], ws[1] if len(ws) == 2 else b''
        datatype = parse_datatype(rest, parsers)
        return name, datatype
    raise Exception('Could not parse "%s" as DOMAIN declaration' %(u8(b' '.join(ws))))

def parse_table(line):
    ws = line.split()
    if len(ws) < 2:
        raise Exception('TABLE declaration syntax: TABLE <name> columns...')
    return (ws[0], ws[1:])

def parse_logic_tuple(line):
    ws = line.split()
    return ws[0], ws[1:]

def parse_key(line):
    name = line  # XXX
    t, vs = parse_logic_tuple(line)
    return name, (t, vs)

def parse_ref(line):
    line = line.strip()
    parts = line.split(b'=>')
    if len(parts) != 2:
        raise Exception('Failed to parse "%s" as REFERENCE constraint' %(u8(line),))
    ld, fd = parts[0].strip(), parts[1].strip()
    name = line  # XXX
    lt, lvs = parse_logic_tuple(ld)
    ft, fvs = parse_logic_tuple(fd)
    return name, (lt, lvs, ft, fvs)

def parse_schema(lines, parsers=None):
    if parsers is None:
        parsers = dict(default_parsers)
    doms = {}
    tables = {}
    keys = {}
    refs = {}
    for line in lines:
        line = line.strip()
        ws = line.split(None, 1)
        if not ws:
            continue
        decl, rest = ws
        if decl == b'DOMAIN':
            name, dom = parse_domain(rest, parsers)
            doms[name] = dom
        if decl == b'TABLE':
            name, tdoms = parse_table(rest)
            if name in tables:
                raise Exception('Table "%s" already declared' %(u8(name),))
            tables[name] = tdoms
        if decl == b'KEY':
            name, key = parse_key(line[4:])
            keys[name] = key
        if decl == b'REFERENCE':
            name, ref = parse_ref(line[9:])
            refs[name] = ref

    schtables = {}
    for table, tdoms in tables.items():
        for dom in tdoms:
            if dom not in doms:
                raise Exception('Declaration of table "%s" references unknown domain "%s"' %(u8(table), u8(dom)))
        schtables[table] = tuple(doms[dom] for dom in tdoms)

    schkeys = {}
    for name, (table, vars) in keys.items():
        ix = []
        if table not in tables:
            raise Exception('No such table: "%s" while parsing KEY constraint "%s"' %(u8(name), u8(name)))
        if len(vars) != len(tables[table]):
            raise Exception('Arity mismatch for table "%s" while parsing KEY constraint "%s"' %(u8(name), u8(name)))
        for i, v in enumerate(vars):
            if v != b'*':
                if not v.isalpha():
                    raise Exception('Invalid variable "%s" while parsing "%s" as logic tuple' %(u8(v), u8(name)))
                ix.append(i)
        schkeys[name] = table, ix

    schrefs = {}
    for name, (lt, lvs, ft, fvs) in refs.items():
        lix, fix = [], []
        for (table, vars, ix) in [(lt,lvs,lix), (ft,fvs,fix)]:
            if table not in tables:
                raise Exception('No such table: "%s" while parsing REFERENCE constraint "%s"' %(u8(table), u8(name)))
            if len(vars) != len(tables[table]):
                raise Exception('Arity mismatch for table "%s" while parsing KEY constraint "%s"' %(u8(table), u8(name)))
            for i, v in enumerate(vars):
                if v != b'*':
                    if not v.isalpha():
                        raise Exception('Invalid variable "%s" while parsing "%s" as logic tuple' %(u8(table), u8(name)))
                    ix.append(i)
        schrefs[name] = lt, lix, ft, fix

    return Schema(schtables, schkeys, schrefs)

def hexconvert(c):
    x = ord(c)
    if 48 <= x < 58:
        return x - 48
    if 97 <= x < 103:
        return 10 + x - 97
    return None

def parse_atom(line, i):
    end = len(line)
    x = i
    while i < end and line[i] > 0x20 and line[i] != 0x7f:
        i += 1
    if x == i:
        raise Exception('EOL or invalid character while expecting atom at byte %d in line "%s"' %(i, u8(line)))
    return line[x:i], i

def parse_string(line, i):
    end = len(line)
    assert line[i] == 0x22
    i += 1
    s = []
    while i < end:
        if line[i] == 0x22:
            return bytes(s), i+1
        if line[i] == 0x5c:
            if end - i < 2 or (line[i+1] == 'x' and end - i < 4):
                raise Exception('Failed to parse escape sequence at byte %d in line %s' %(i, u8(line)))
            m = { 0x22: 0x22, 0x5c: 0x5c, 0x6e: 0x0a, 0x72: 0x0d, 0x74: 0x09 }
            if line[i+1] in m:
                s.append(m[line[i+1]])
                i += 2
            elif line[i+1] == 0x78:
                hi = hexconvert(line[i+2])
                lo = hexconvert(line[i+3])
                if hi is None or lo is None:
                    raise Exception('Failed to convert hex sequence at byte %d in line %s' %(i, u8(line)))
                s.append(hi*16 + lo)
                i += 4
            else:
                raise Exception('Failed to convert escape sequence at byte %d in line %s' %(i, u8(line)))
        elif line[i] >= 0x20 and line[i] != 0x7f:
            s.append(line[i])
            i += 1
        else:
            raise Exception('Failed to parse string literal at byte %d in line %s' %(i, u8(line)))

def parse_space(line, i):
    end = len(line)
    if i == end:
        raise Exception('Expected whitespace but found EOL in line %s' %(u8(line),))
    if line[i] != 0x20:
        raise Exception('Expected whitespace in line %s at position %d' %(u8(line), i))
    return i+1

def parse_row(line, schema):
    end = len(line)
    i = 0
    cs = tuple()
    t, i = parse_atom(line, 0)
    for col in schema.tableinfo[t]:
        i = parse_space(line, i)
        if col.syntaxtype == SYNTAX_ATOM:
            s, i = parse_atom(line, i)
        else:
            s, i = parse_string(line, i)
        cs = cs + (col.decode(s),)
    if i != end:
        raise Exception('Unexpected trailing characters at byte %d in line %s' %(i, u8(line)))
    return t, cs

def split_schema(lines):
    lines = L1(iter(lines))
    schlines = []
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if not line.startswith(b'%'):
            lines.unget(line)
            break
        schlines.append(line.lstrip(b'% '))
    return schlines, lines

def parse_db(lines, schema=None):
    if schema is None:
        schemalines, lines = split_schema(lines)
        schema = parse_schema(schemalines)
    db = Database(schema)
    for line in lines:
        line = line.strip()
        if not line:
            continue
        table, row = parse_row(line, schema)
        db.add_row(table, row)
    return db

if __name__ == '__main__':
    "check WSL file given at stdin"
    import sys
    lines = BinaryLines(sys.stdin)
    db = parse_db(lines)
    db.check_referential_integrity()
    #print(db.relvar)
